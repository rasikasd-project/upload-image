'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var PropTypes = require('prop-types');
var index$1 = require('../utils/index.js');
var _rollupPluginBabelHelpers = require('../_virtual/_rollupPluginBabelHelpers.js');
var index = require('../Editor/index.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var PropTypes__default = /*#__PURE__*/_interopDefaultLegacy(PropTypes);

function ControlledEditor({
  value: providedValue,
  onChange,
  editorDidMount,
  ...props
}) {
  const editor = React.useRef(null);
  const listener = React.useRef(null);
  const value = React.useRef(providedValue); // to avoid unnecessary updates in `handleEditorModelChange`
  // (that depends on the `current value` and will trigger to update `attachChangeEventListener`,
  // thus, the listener will be disposed and attached again for every value change)
  // the current value is stored in ref (useRef) instead of being a dependency of `handleEditorModelChange`

  value.current = providedValue;
  const handleEditorModelChange = React.useCallback(event => {
    const editorValue = editor.current.getValue();

    if (value.current !== editorValue) {
      const directChange = onChange(event, editorValue);

      if (typeof directChange === 'string' && editorValue !== directChange) {
        editor.current.setValue(directChange);
      }
    }
  }, [onChange]);
  const attachChangeEventListener = React.useCallback(() => {
    var _editor$current;

    listener.current = (_editor$current = editor.current) === null || _editor$current === void 0 ? void 0 : _editor$current.onDidChangeModelContent(handleEditorModelChange);
  }, [handleEditorModelChange]);
  React.useEffect(() => {
    attachChangeEventListener();
    return () => {
      var _listener$current;

      return (_listener$current = listener.current) === null || _listener$current === void 0 ? void 0 : _listener$current.dispose();
    };
  }, [attachChangeEventListener]);
  const handleEditorDidMount = React.useCallback((getValue, _editor) => {
    editor.current = _editor;
    attachChangeEventListener();
    editorDidMount(getValue, _editor);
  }, [attachChangeEventListener, editorDidMount]);
  return /*#__PURE__*/React__default['default'].createElement(index['default'], _rollupPluginBabelHelpers['extends']({
    value: providedValue,
    editorDidMount: handleEditorDidMount,
    _isControlledMode: true
  }, props));
}

ControlledEditor.propTypes = {
  value: PropTypes__default['default'].string,
  editorDidMount: PropTypes__default['default'].func,
  onChange: PropTypes__default['default'].func
};
ControlledEditor.defaultProps = {
  editorDidMount: index$1.noop,
  onChange: index$1.noop
};

exports.default = ControlledEditor;
