(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@monaco-editor/loader'), require('react'), require('prop-types')) :
  typeof define === 'function' && define.amd ? define(['exports', '@monaco-editor/loader', 'react', 'prop-types'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.monaco_react = {}, global.monaco_loader, global.React, global.PropTypes));
}(this, (function (exports, monaco, React, PropTypes) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var monaco__default = /*#__PURE__*/_interopDefaultLegacy(monaco);
  var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
  var PropTypes__default = /*#__PURE__*/_interopDefaultLegacy(PropTypes);

  const loadingStyles = {
    display: 'flex',
    height: '100%',
    width: '100%',
    justifyContent: 'center',
    alignItems: 'center'
  };

  function Loading({
    content
  }) {
    return /*#__PURE__*/React__default['default'].createElement("div", {
      style: loadingStyles
    }, content);
  }

  const styles = {
    wrapper: {
      display: 'flex',
      position: 'relative',
      textAlign: 'initial'
    },
    fullWidth: {
      width: '100%'
    },
    hide: {
      display: 'none'
    }
  };

  // one of the reasons why we use a separate prop for passing ref instead of using forwardref

  function MonacoContainer({
    width,
    height,
    isEditorReady,
    loading,
    _ref,
    className,
    wrapperClassName
  }) {
    return /*#__PURE__*/React__default['default'].createElement("section", {
      style: { ...styles.wrapper,
        width,
        height
      },
      className: wrapperClassName
    }, !isEditorReady && /*#__PURE__*/React__default['default'].createElement(Loading, {
      content: loading
    }), /*#__PURE__*/React__default['default'].createElement("div", {
      ref: _ref,
      style: { ...styles.fullWidth,
        ...(!isEditorReady && styles.hide)
      },
      className: className
    }));
  }

  MonacoContainer.propTypes = {
    width: PropTypes__default['default'].oneOfType([PropTypes__default['default'].number, PropTypes__default['default'].string]).isRequired,
    height: PropTypes__default['default'].oneOfType([PropTypes__default['default'].number, PropTypes__default['default'].string]).isRequired,
    loading: PropTypes__default['default'].oneOfType([PropTypes__default['default'].element, PropTypes__default['default'].string]).isRequired,
    isEditorReady: PropTypes__default['default'].bool.isRequired,
    className: PropTypes__default['default'].string,
    wrapperClassName: PropTypes__default['default'].string
  };

  var MonacoContainer$1 = /*#__PURE__*/React.memo(MonacoContainer);

  function useMount(effect) {
    React.useEffect(effect, []);
  }

  function useUpdate(effect, deps, applyChanges = true) {
    const isInitialMount = React.useRef(true);
    React.useEffect(isInitialMount.current || !applyChanges ? () => {
      isInitialMount.current = false;
    } : effect, deps);
  }

  function noop() {}

  function DiffEditor({
    original,
    modified,
    language,
    originalLanguage,
    modifiedLanguage,
    editorDidMount,
    theme,
    width,
    height,
    loading,
    options,
    className,
    wrapperClassName
  }) {
    const [isEditorReady, setIsEditorReady] = React.useState(false);
    const [isMonacoMounting, setIsMonacoMounting] = React.useState(true);
    const editorRef = React.useRef(null);
    const monacoRef = React.useRef(null);
    const containerRef = React.useRef(null);
    const editorDidMountRef = React.useRef(editorDidMount);
    useMount(() => {
      const cancelable = monaco__default['default'].init();
      cancelable.then(monaco => (monacoRef.current = monaco) && setIsMonacoMounting(false)).catch(error => (error === null || error === void 0 ? void 0 : error.type) !== 'cancelation' && console.error('Monaco initialization: error:', error));
      return () => editorRef.current ? disposeEditor() : cancelable.cancel();
    });
    useUpdate(() => {
      editorRef.current.getModel().modified.setValue(modified);
    }, [modified], isEditorReady);
    useUpdate(() => {
      editorRef.current.getModel().original.setValue(original);
    }, [original], isEditorReady);
    useUpdate(() => {
      const {
        original,
        modified
      } = editorRef.current.getModel();
      monacoRef.current.editor.setModelLanguage(original, originalLanguage || language);
      monacoRef.current.editor.setModelLanguage(modified, modifiedLanguage || language);
    }, [language, originalLanguage, modifiedLanguage], isEditorReady);
    useUpdate(() => {
      monacoRef.current.editor.setTheme(theme);
    }, [theme], isEditorReady);
    useUpdate(() => {
      editorRef.current.updateOptions(options);
    }, [options], isEditorReady);
    const setModels = React.useCallback(() => {
      const originalModel = monacoRef.current.editor.createModel(original, originalLanguage || language);
      const modifiedModel = monacoRef.current.editor.createModel(modified, modifiedLanguage || language);
      editorRef.current.setModel({
        original: originalModel,
        modified: modifiedModel
      });
    }, [language, modified, modifiedLanguage, original, originalLanguage]);
    const createEditor = React.useCallback(() => {
      editorRef.current = monacoRef.current.editor.createDiffEditor(containerRef.current, {
        automaticLayout: true,
        ...options
      });
      setModels();
      monacoRef.current.editor.setTheme(theme);
      setIsEditorReady(true);
    }, [options, theme, setModels]);
    React.useEffect(() => {
      if (isEditorReady) {
        const {
          original,
          modified
        } = editorRef.current.getModel();
        editorDidMountRef.current(modified.getValue.bind(modified), original.getValue.bind(original), editorRef.current);
      }
    }, [isEditorReady]);
    React.useEffect(() => {
      !isMonacoMounting && !isEditorReady && createEditor();
    }, [isMonacoMounting, isEditorReady, createEditor]);

    const disposeEditor = () => editorRef.current.dispose();

    return /*#__PURE__*/React__default['default'].createElement(MonacoContainer$1, {
      width: width,
      height: height,
      isEditorReady: isEditorReady,
      loading: loading,
      _ref: containerRef,
      className: className,
      wrapperClassName: wrapperClassName
    });
  }

  DiffEditor.propTypes = {
    original: PropTypes__default['default'].string,
    modified: PropTypes__default['default'].string,
    language: PropTypes__default['default'].string,
    originalLanguage: PropTypes__default['default'].string,
    modifiedLanguage: PropTypes__default['default'].string,
    editorDidMount: PropTypes__default['default'].func,
    theme: PropTypes__default['default'].string,
    width: PropTypes__default['default'].oneOfType([PropTypes__default['default'].number, PropTypes__default['default'].string]),
    height: PropTypes__default['default'].oneOfType([PropTypes__default['default'].number, PropTypes__default['default'].string]),
    loading: PropTypes__default['default'].oneOfType([PropTypes__default['default'].element, PropTypes__default['default'].string]),
    options: PropTypes__default['default'].object,
    className: PropTypes__default['default'].string,
    wrapperClassName: PropTypes__default['default'].string
  };
  DiffEditor.defaultProps = {
    editorDidMount: noop,
    theme: 'light',
    width: '100%',
    height: '100%',
    loading: 'Loading...',
    options: {}
  };

  var index = /*#__PURE__*/React.memo(DiffEditor);

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function Editor({
    value,
    language,
    editorDidMount,
    theme,
    line,
    width,
    height,
    loading,
    options,
    overrideServices,
    _isControlledMode,
    className,
    wrapperClassName
  }) {
    const [isEditorReady, setIsEditorReady] = React.useState(false);
    const [isMonacoMounting, setIsMonacoMounting] = React.useState(true);
    const editorRef = React.useRef(null);
    const monacoRef = React.useRef(null);
    const containerRef = React.useRef(null);
    const editorDidMountRef = React.useRef(editorDidMount);
    useMount(() => {
      const cancelable = monaco__default['default'].init();
      cancelable.then(monaco => (monacoRef.current = monaco) && setIsMonacoMounting(false)).catch(error => (error === null || error === void 0 ? void 0 : error.type) !== 'cancelation' && console.error('Monaco initialization: error:', error));
      return () => editorRef.current ? disposeEditor() : cancelable.cancel();
    });
    useUpdate(() => {
      editorRef.current.updateOptions(options);
    }, [options], isEditorReady);
    useUpdate(() => {
      if (editorRef.current.getOption(monacoRef.current.editor.EditorOption.readOnly)) {
        editorRef.current.setValue(value);
      } else {
        if (value !== editorRef.current.getValue()) {
          editorRef.current.executeEdits('', [{
            range: editorRef.current.getModel().getFullModelRange(),
            text: value,
            forceMoveMarkers: true
          }]);

          if (_isControlledMode) {
            const model = editorRef.current.getModel();
            model.forceTokenization(model.getLineCount());
          }

          editorRef.current.pushUndoStop();
        }
      }
    }, [value], isEditorReady);
    useUpdate(() => {
      monacoRef.current.editor.setModelLanguage(editorRef.current.getModel(), language);
    }, [language], isEditorReady);
    useUpdate(() => {
      editorRef.current.setScrollPosition({
        scrollTop: line
      });
    }, [line], isEditorReady);
    useUpdate(() => {
      monacoRef.current.editor.setTheme(theme);
    }, [theme], isEditorReady);
    const createEditor = React.useCallback(() => {
      editorRef.current = monacoRef.current.editor.create(containerRef.current, {
        value,
        language,
        automaticLayout: true,
        ...options
      }, overrideServices);
      monacoRef.current.editor.setTheme(theme);
      setIsEditorReady(true);
    }, [language, options, overrideServices, theme, value]);
    React.useEffect(() => {
      if (isEditorReady) {
        editorDidMountRef.current(editorRef.current.getValue.bind(editorRef.current), editorRef.current);
      }
    }, [isEditorReady]);
    React.useEffect(() => {
      !isMonacoMounting && !isEditorReady && createEditor();
    }, [isMonacoMounting, isEditorReady, createEditor]);

    const disposeEditor = () => editorRef.current.dispose();

    return /*#__PURE__*/React__default['default'].createElement(MonacoContainer$1, {
      width: width,
      height: height,
      isEditorReady: isEditorReady,
      loading: loading,
      _ref: containerRef,
      className: className,
      wrapperClassName: wrapperClassName
    });
  }

  Editor.propTypes = {
    value: PropTypes__default['default'].string,
    language: PropTypes__default['default'].string,
    editorDidMount: PropTypes__default['default'].func,
    theme: PropTypes__default['default'].string,
    line: PropTypes__default['default'].number,
    width: PropTypes__default['default'].oneOfType([PropTypes__default['default'].number, PropTypes__default['default'].string]),
    height: PropTypes__default['default'].oneOfType([PropTypes__default['default'].number, PropTypes__default['default'].string]),
    loading: PropTypes__default['default'].oneOfType([PropTypes__default['default'].element, PropTypes__default['default'].string]),
    options: PropTypes__default['default'].object,
    className: PropTypes__default['default'].string,
    wrapperClassName: PropTypes__default['default'].string,
    overrideServices: PropTypes__default['default'].object,
    _isControlledMode: PropTypes__default['default'].bool
  };
  Editor.defaultProps = {
    editorDidMount: noop,
    theme: 'light',
    width: '100%',
    height: '100%',
    loading: 'Loading...',
    options: {},
    overrideServices: {},
    _isControlledMode: false
  };

  var Editor$1 = /*#__PURE__*/React.memo(Editor);

  function ControlledEditor({
    value: providedValue,
    onChange,
    editorDidMount,
    ...props
  }) {
    const editor = React.useRef(null);
    const listener = React.useRef(null);
    const value = React.useRef(providedValue); // to avoid unnecessary updates in `handleEditorModelChange`
    // (that depends on the `current value` and will trigger to update `attachChangeEventListener`,
    // thus, the listener will be disposed and attached again for every value change)
    // the current value is stored in ref (useRef) instead of being a dependency of `handleEditorModelChange`

    value.current = providedValue;
    const handleEditorModelChange = React.useCallback(event => {
      const editorValue = editor.current.getValue();

      if (value.current !== editorValue) {
        const directChange = onChange(event, editorValue);

        if (typeof directChange === 'string' && editorValue !== directChange) {
          editor.current.setValue(directChange);
        }
      }
    }, [onChange]);
    const attachChangeEventListener = React.useCallback(() => {
      var _editor$current;

      listener.current = (_editor$current = editor.current) === null || _editor$current === void 0 ? void 0 : _editor$current.onDidChangeModelContent(handleEditorModelChange);
    }, [handleEditorModelChange]);
    React.useEffect(() => {
      attachChangeEventListener();
      return () => {
        var _listener$current;

        return (_listener$current = listener.current) === null || _listener$current === void 0 ? void 0 : _listener$current.dispose();
      };
    }, [attachChangeEventListener]);
    const handleEditorDidMount = React.useCallback((getValue, _editor) => {
      editor.current = _editor;
      attachChangeEventListener();
      editorDidMount(getValue, _editor);
    }, [attachChangeEventListener, editorDidMount]);
    return /*#__PURE__*/React__default['default'].createElement(Editor$1, _extends({
      value: providedValue,
      editorDidMount: handleEditorDidMount,
      _isControlledMode: true
    }, props));
  }

  ControlledEditor.propTypes = {
    value: PropTypes__default['default'].string,
    editorDidMount: PropTypes__default['default'].func,
    onChange: PropTypes__default['default'].func
  };
  ControlledEditor.defaultProps = {
    editorDidMount: noop,
    onChange: noop
  };

  var index$1 = /*#__PURE__*/React.memo(ControlledEditor);

  Object.defineProperty(exports, 'monaco', {
    enumerable: true,
    get: function () {
      return monaco__default['default'];
    }
  });
  exports.ControlledEditor = index$1;
  exports.DiffEditor = index;
  exports.default = Editor$1;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
