{"ast":null,"code":"import React, { useRef, useCallback, useEffect } from 'react';\nimport PropTypes from 'prop-types';\nimport { noop } from '../utils/index.js';\nimport { extends as _extends } from '../_virtual/_rollupPluginBabelHelpers.js';\nimport Editor from '../Editor/index.js';\n\nfunction ControlledEditor({\n  value: providedValue,\n  onChange,\n  editorDidMount,\n  ...props\n}) {\n  const editor = useRef(null);\n  const listener = useRef(null);\n  const value = useRef(providedValue); // to avoid unnecessary updates in `handleEditorModelChange`\n  // (that depends on the `current value` and will trigger to update `attachChangeEventListener`,\n  // thus, the listener will be disposed and attached again for every value change)\n  // the current value is stored in ref (useRef) instead of being a dependency of `handleEditorModelChange`\n\n  value.current = providedValue;\n  const handleEditorModelChange = useCallback(event => {\n    const editorValue = editor.current.getValue();\n\n    if (value.current !== editorValue) {\n      const directChange = onChange(event, editorValue);\n\n      if (typeof directChange === 'string' && editorValue !== directChange) {\n        editor.current.setValue(directChange);\n      }\n    }\n  }, [onChange]);\n  const attachChangeEventListener = useCallback(() => {\n    var _editor$current;\n\n    listener.current = (_editor$current = editor.current) === null || _editor$current === void 0 ? void 0 : _editor$current.onDidChangeModelContent(handleEditorModelChange);\n  }, [handleEditorModelChange]);\n  useEffect(() => {\n    attachChangeEventListener();\n    return () => {\n      var _listener$current;\n\n      return (_listener$current = listener.current) === null || _listener$current === void 0 ? void 0 : _listener$current.dispose();\n    };\n  }, [attachChangeEventListener]);\n  const handleEditorDidMount = useCallback((getValue, _editor) => {\n    editor.current = _editor;\n    attachChangeEventListener();\n    editorDidMount(getValue, _editor);\n  }, [attachChangeEventListener, editorDidMount]);\n  return /*#__PURE__*/React.createElement(Editor, _extends({\n    value: providedValue,\n    editorDidMount: handleEditorDidMount,\n    _isControlledMode: true\n  }, props));\n}\n\nControlledEditor.propTypes = {\n  value: PropTypes.string,\n  editorDidMount: PropTypes.func,\n  onChange: PropTypes.func\n};\nControlledEditor.defaultProps = {\n  editorDidMount: noop,\n  onChange: noop\n};\nexport default ControlledEditor;","map":{"version":3,"sources":["C:/Users/One Life/Projects_Dac/upload-image/ValidationProject/node_modules/@monaco-editor/react/lib/es/ControlledEditor/ControlledEditor.js"],"names":["React","useRef","useCallback","useEffect","PropTypes","noop","extends","_extends","Editor","ControlledEditor","value","providedValue","onChange","editorDidMount","props","editor","listener","current","handleEditorModelChange","event","editorValue","getValue","directChange","setValue","attachChangeEventListener","_editor$current","onDidChangeModelContent","_listener$current","dispose","handleEditorDidMount","_editor","createElement","_isControlledMode","propTypes","string","func","defaultProps"],"mappings":"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","sourcesContent":["import React, { useRef, useCallback, useEffect } from 'react';\nimport PropTypes from 'prop-types';\nimport { noop } from '../utils/index.js';\nimport { extends as _extends } from '../_virtual/_rollupPluginBabelHelpers.js';\nimport Editor from '../Editor/index.js';\n\nfunction ControlledEditor({\n  value: providedValue,\n  onChange,\n  editorDidMount,\n  ...props\n}) {\n  const editor = useRef(null);\n  const listener = useRef(null);\n  const value = useRef(providedValue); // to avoid unnecessary updates in `handleEditorModelChange`\n  // (that depends on the `current value` and will trigger to update `attachChangeEventListener`,\n  // thus, the listener will be disposed and attached again for every value change)\n  // the current value is stored in ref (useRef) instead of being a dependency of `handleEditorModelChange`\n\n  value.current = providedValue;\n  const handleEditorModelChange = useCallback(event => {\n    const editorValue = editor.current.getValue();\n\n    if (value.current !== editorValue) {\n      const directChange = onChange(event, editorValue);\n\n      if (typeof directChange === 'string' && editorValue !== directChange) {\n        editor.current.setValue(directChange);\n      }\n    }\n  }, [onChange]);\n  const attachChangeEventListener = useCallback(() => {\n    var _editor$current;\n\n    listener.current = (_editor$current = editor.current) === null || _editor$current === void 0 ? void 0 : _editor$current.onDidChangeModelContent(handleEditorModelChange);\n  }, [handleEditorModelChange]);\n  useEffect(() => {\n    attachChangeEventListener();\n    return () => {\n      var _listener$current;\n\n      return (_listener$current = listener.current) === null || _listener$current === void 0 ? void 0 : _listener$current.dispose();\n    };\n  }, [attachChangeEventListener]);\n  const handleEditorDidMount = useCallback((getValue, _editor) => {\n    editor.current = _editor;\n    attachChangeEventListener();\n    editorDidMount(getValue, _editor);\n  }, [attachChangeEventListener, editorDidMount]);\n  return /*#__PURE__*/React.createElement(Editor, _extends({\n    value: providedValue,\n    editorDidMount: handleEditorDidMount,\n    _isControlledMode: true\n  }, props));\n}\n\nControlledEditor.propTypes = {\n  value: PropTypes.string,\n  editorDidMount: PropTypes.func,\n  onChange: PropTypes.func\n};\nControlledEditor.defaultProps = {\n  editorDidMount: noop,\n  onChange: noop\n};\n\nexport default ControlledEditor;\n"]},"metadata":{},"sourceType":"module"}